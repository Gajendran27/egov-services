package org.egov.pgr.service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.egov.common.contract.request.RequestInfo;
import org.egov.pgr.contract.Comment;
import org.egov.pgr.contract.CountResponse;
import org.egov.pgr.contract.IdResponse;
import org.egov.pgr.contract.Media;
import org.egov.pgr.contract.ServiceReq;
import org.egov.pgr.contract.ServiceReqRequest;
import org.egov.pgr.contract.ServiceReqResponse;
import org.egov.pgr.contract.ServiceReqSearchCriteria;
import org.egov.pgr.repository.IdGenRepo;
import org.egov.pgr.repository.MDMSRespository;
import org.egov.pgr.repository.ServiceRequestRepository;
import org.egov.pgr.utils.PGRConstants;
import org.egov.pgr.utils.ResponseInfoFactory;
import org.egov.tracer.kafka.LogAwareKafkaTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class ServiceRequestService {

	@Value("${kafka.topics.save.servicereq}")
	private String saveTopic;

	@Value("${kafka.topics.update.servicereq}")
	private String updateTopic;

	@Autowired
	private ResponseInfoFactory factory;

	@Autowired
	private IdGenRepo idGenRepo;

	@Autowired
	private ServiceRequestRepository serviceRequestRepository;
	
	@Autowired
	private MDMSRespository mDMSRespository;

	@Autowired
	private LogAwareKafkaTemplate<String, Object> kafkaProducer;

	/***
	 * Asynchronous method performs business logic if any and adds the data to
	 * persister queue on create topic
	 * 
	 * @param request
	 */
	public ServiceReqResponse create(ServiceReqRequest request) {

		log.debug(" the incoming request obj in service : {}", request);

		RequestInfo requestInfo = request.getRequestInfo();
		List<ServiceReq> serviceReqs = request.getServiceReq();
		String tenantId = serviceReqs.get(0).getTenantId();
		List<Media> mediaList = new ArrayList<>();
		List<Comment> commentList = new ArrayList<>();
		Integer servReqLen = serviceReqs.size();
		int servReqCount = 0;

		List<String> servReqIdList = getIdList(requestInfo, tenantId, servReqLen, PGRConstants.SERV_REQ_ID_NAME,
				PGRConstants.SERV_REQ_ID_FORMAT);

		for (ServiceReq servReq : serviceReqs) {
			servReq.setServiceRequestId(servReqIdList.get(servReqCount++));

			if (servReq.getComments() != null)
				commentList.addAll(servReq.getComments());
			if (servReq.getMedia() != null)
				mediaList.addAll(servReq.getMedia());
		}

		setIdsForSubLists(requestInfo, mediaList, commentList, tenantId);
		kafkaProducer.send(saveTopic, request);
		return getServiceReqResponse(request);
	}

	/***
	 * Asynchronous method performs business logic if any and adds the data to
	 * persister queue on update topic
	 * 
	 * @param request
	 */
	public ServiceReqResponse update(ServiceReqRequest request) {

		log.debug(" the incoming request obj in service : {}", request);

		RequestInfo requestInfo = request.getRequestInfo();
		List<ServiceReq> serviceReqs = request.getServiceReq();
		String tenantId = serviceReqs.get(0).getTenantId();
		List<Media> mediaList = new ArrayList<>();
		List<Comment> commentList = new ArrayList<>();

		for (ServiceReq servReq : serviceReqs) {
			addSubListForUpdate(mediaList, commentList, servReq.getMedia(), servReq.getComments());
		}

		setIdsForSubLists(requestInfo, mediaList, commentList, tenantId);
		kafkaProducer.send(updateTopic, request);
		return getServiceReqResponse(request);
	}

	/**
	 * to filter the sublist object for idgeneration if they are null
	 * 
	 * @param parentMediaList
	 * @param parentCommentList
	 * @param subMediaList
	 * @param subCommentsList
	 */
	private void addSubListForUpdate(List<Media> parentMediaList, List<Comment> parentCommentList,
			List<Media> subMediaList, List<Comment> subCommentsList) {

		if (subMediaList != null)
			subMediaList.forEach(media -> {
				if (media.getId() == null)
					parentMediaList.add(media);
			});

		if (subCommentsList != null)
			subCommentsList.forEach(comment -> {
				if (comment.getId() == null)
					parentCommentList.add(comment);
			});
	}

	/**
	 * method to set Id generated by system using respective sequences to the media
	 * and comment list
	 * 
	 * @param requestInfo
	 * @param mediaList
	 * @param commentList
	 * @param tenantId
	 */
	private void setIdsForSubLists(RequestInfo requestInfo, List<Media> mediaList, List<Comment> commentList,
			String tenantId) {

		int mediaLen = mediaList.size();
		int commentLen = commentList.size();

		int count = 0;
		if (mediaLen > 0) {
			List<String> mediaIdList = getIdList(requestInfo, tenantId, mediaLen, PGRConstants.MEDIA_ID_NAME,
					PGRConstants.MEDIA_ID_FORMAT);
			for (Media media : mediaList)
				media.setId(mediaIdList.get(count++));
		}

		count = 0;
		if (commentLen > 0) {
			List<String> commentIdList = getIdList(requestInfo, tenantId, commentLen, PGRConstants.COMMENT_ID_NAME,
					PGRConstants.COMMENT_ID_FORMAT);
			for (Comment comment : commentList)
				comment.setId(commentIdList.get(count++));
		}
	}

	/**
	 * method to parse the IdGenResponse from IdgenRepo to List of String ids
	 * required by the respective methods
	 * 
	 * @param requestInfo
	 * @param tenantId
	 * @param length
	 * @param idKey
	 * @param idformat
	 * 
	 */
	private List<String> getIdList(RequestInfo requestInfo, String tenantId, Integer length, String idKey,
			String idformat) {

		return idGenRepo.getId(requestInfo, tenantId, length, idKey, idformat).getIdResponses().stream()
				.map(IdResponse::getId).collect(Collectors.toList());
	}

	/**
	 * returns ServiceReqResponse built based on the given ServiceReqRequest
	 * 
	 * @param serviceReqRequest
	 * @return serviceReqResponse
	 */
	public ServiceReqResponse getServiceReqResponse(ServiceReqRequest serviceReqRequest) {

		return ServiceReqResponse.builder()
				.responseInfo(factory.createResponseInfoFromRequestInfo(serviceReqRequest.getRequestInfo(), true))
				.serviceReq(serviceReqRequest.getServiceReq()).build();
	}

	/**
	 * Method to return service requests received from the repo to the controller in
	 * the reqd format
	 * 
	 * @param requestInfo
	 * @param serviceReqSearchCriteria
	 * @return ServiceReqResponse
	 * @author vishal
	 */
	public ServiceReqResponse getServiceRequests(RequestInfo requestInfo,
			ServiceReqSearchCriteria serviceReqSearchCriteria) {
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		ServiceReqResponse serviceReqResponse = null;
		if(null != serviceReqSearchCriteria.getGroup() || !serviceReqSearchCriteria.getGroup().isEmpty()) {
			Object response = fetchServiceCodes(requestInfo, serviceReqSearchCriteria.getTenantId(), serviceReqSearchCriteria.getGroup());
			if(null == response)
				return new ServiceReqResponse();
			List<String> serviceCodes = new ArrayList<>();
			try {
				serviceCodes = JsonPath.read(response, "$.*.serviceCodes");
			}catch(Exception e) {
				log.info("MDMS response couldn't be parsed: ",e);
				return new ServiceReqResponse();
			}
			serviceReqSearchCriteria.setServiceCodes(serviceCodes);
		}
		Object response = serviceRequestRepository.getServiceRequests(requestInfo, serviceReqSearchCriteria);
		log.info("Searcher response: ", response);
		if (null == response) {
			return new ServiceReqResponse(factory.createResponseInfoFromRequestInfo(requestInfo, false),
					new ArrayList<ServiceReq>());
		}
		serviceReqResponse = mapper.convertValue(response, ServiceReqResponse.class);
		return serviceReqResponse;
	}

	/**
	 * Fetches count of service requests and returns in the reqd format.
	 * 
	 * @param requestInfo
	 * @param serviceReqSearchCriteria
	 * @return Object
	 * @author vishal
	 */
	public Object getCount(RequestInfo requestInfo, ServiceReqSearchCriteria serviceReqSearchCriteria) {
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		Object response = serviceRequestRepository.getCount(requestInfo, serviceReqSearchCriteria);
		log.info("Searcher response: ", response);
		if (null == response) {
			return new CountResponse(factory.createResponseInfoFromRequestInfo(requestInfo, false), 0D);
		}
		Double count = JsonPath.read(response, "$.count[0].count");
		return new CountResponse(factory.createResponseInfoFromRequestInfo(requestInfo, false), count);
	}
	
	
	/**
	 * method to fetch service codes from mdms based on dept
	 * 
	 * @param requestInfo
	 * @param tenantId
	 * @param department
	 * @return Object
	 * @author vishal
	 */
	public Object fetchServiceCodes(RequestInfo requestInfo,
			String tenantId, String department) {
		return mDMSRespository.fetchServiceCodes(requestInfo, tenantId, department);
		
	}

}
